(* 
  generates the trigger table for a DPT program's entry 
  events, based solely on a configuration json file.
*)

module CL = Caml.List
module BS = Batteries.String
open MiscUtils
open Printf
open Format
open Core
module DBG = BackendLogging
open Yojson.Basic.Util

let outc = ref None
let dprint_endline = ref DBG.no_printf
let start_log () = DBG.start_mlog __FILE__ outc dprint_endline
exception Error of string
let error s = raise (Error s)

(* pragma in the harness that gets replaced 
   with the code generated by this module. *)
let obj_pragma = "ENTRY_TRIGGER_OBJECTS"
let call_pragma = "ENTRY_TRIGGER_CALL"

(* Take a list of lists of objects of the form 
    [[a1; a2; ... aj]; [b1; b2; ... bk]; ... [c1; c2; ... cl]]
  Return a list of all possible combinations of the form 
    [[a1; b1; ... c1]; [a1; b1; ... c2]; [a1; b1; ... ck]; ... [a1; b2; ... c1] ... [aj; bk; ... cl]] *)
let rec all_combinations (stss: 'a list list) : 'a list list = 
  match stss with 
    | [] -> []
    (* all combinations of a list is a list of singletons *)
    | sts::[] -> CL.map (fun st -> [st]) sts
    (* all combinations of a singleton list with subsequent lists --> 
     prepend the singleton to all lists. *)
    | [st]::stss -> 
      let combos = all_combinations stss in 
      CL.map (fun (combo: 'a list) -> st::combo) combos
    (* all combinations with every element of first list, separately, then flatten. *)
    | sts::stss ->       
      CL.map 
        (fun st -> all_combinations ([st]::stss))
        sts
      |> CL.flatten
;;
(* replace the binding in assoc for k with (k, v). If there is 
   no binding, append (k, v) to the end. *)
let rec replace_or_app (k, v) assoc = 
  match assoc with 
    | [] -> [(k, v)]
    | (hd_k, hd_v)::tl -> (
      match (String.equal hd_k k) with 
        | true -> (k, v)::tl
        | false -> (hd_k, hd_v)::(replace_or_app (k, v) tl)
    ) 
;;


(* internal representation of json event spec block *)
type field_val = 
  | FVInt of int 
  | FVBool of bool
type event_spec = {
  name : string;
  conditions : (string * field_val list) list; (* (p4 field, list of matching values) *)
  arguments : (string * string) list;(* (event parameter, p4 field) *)
}
let extract_event_spec json_spec = 
  (* extract an event_spec from its json representation *)
  let name = member "event" json_spec |> to_string in 
  let guard_json = member "conditions" json_spec |> to_assoc in 
  let args_json = member "arguments" json_spec |> to_assoc in 
  let extract_condition_field (field, vals) = 
    (* extract a single field's triggering values *)
    let convert_val (v : Yojson.Basic.t) : field_val = 
      match v with 
      | `Bool v -> FVBool v
      | `Int v -> FVInt v
      | _ -> error "[TriggerTable.extract_event_spec] json parsing error: field values must be integers or booleans."
    in 
    let vals = convert_each convert_val vals in 
    (field, vals)
  in 
  let process_arg (ev_param, field) = 
    (* extract a single event argument -> field mapping *)
    let field = to_string field in 
    (ev_param, field)
  in 
  let conditions = CL.map extract_condition_field guard_json in 
  let arguments = CL.map process_arg args_json in  
  {name=name; conditions=conditions; arguments=arguments;}
;; 

let string_of_fieldval fv = 
  match fv with 
    | FVInt i -> string_of_int i
    | FVBool b -> string_of_bool b 
;;
let dbg_print_event_spec event_spec =   
  (* print an event spec *)
  print_endline ("event: "^event_spec.name);
  CL.iter (
    fun (f, vs) -> 
    print_endline ("field: "^f);
    print_endline ("values: ");
    CL.iter (fun v -> string_of_fieldval v |> print_endline) vs;
  ) event_spec.conditions;
  print_endline ("arguments: ");
  CL.iter (
    fun (a, f) -> 
    print_endline (event_spec.name^"."^a^" : "^f);
  ) event_spec.arguments;
;;




(* next: 
  1. generate an action for each event that sets the arguments as specified. 
  2. generate a table key that includes all the condition fields.
  3. generate a list of rules for each event. 
  - might be able to re-use code from other parts of the compiler? 

*)

(*** syntax for generating one-off p4 tables from 
     string identifiers and integer values ***)
type field = string
type value = 
  | VInt of int
  | VBool of bool
  | VAny

type command = string
type action = {
  aname : string; 
  aparams : field list;
  acmds : command list;
}
type pattern = 
{
  field : field;
  value : value;
}
type guard = pattern list
type rule = {
  guard : guard;
  action : action;  
  action_args : value list;
}
type ktype = 
  | Exact
  | Ternary

type key = {  
  kfield : field;
  ktype  : ktype;
}
type table = {
  tname : string;
  tkeys : key list;
  tactions : action list;
  trules : rule list;
}

let indent_block s = "  "^(Str.global_replace (Str.regexp "\n") "\n  " s)

let field_to_string f = f 
let fields_to_string (fs: field list) : string = (CL.map field_to_string fs) |> String.concat ~sep:", "

let value_to_string v = match v with 
  | VInt v -> string_of_int v
  | VBool v -> string_of_bool v
  | VAny -> "_"
let values_to_string vs = (CL.map value_to_string vs) |> String.concat ~sep:", "

let command_to_string c = c
let commands_to_string cs = (CL.map command_to_string cs |> String.concat ~sep:"\n")

let action_to_string a = 
  sprintf "action %s(%s) {\n%s\n}" 
    a.aname 
    (fields_to_string a.aparams) 
    (commands_to_string a.acmds |> indent_block)
let actions_to_string a_s = (CL.map action_to_string a_s |> String.concat ~sep:"\n")
let action_name_to_string a = a.aname
let actions_names_to_string a_s = (CL.map action_name_to_string a_s |> String.concat ~sep:"; ")^";"

let pattern_value_to_string p = value_to_string p.value
let pattern_values_to_string ps = CL.map pattern_value_to_string ps |> String.concat ~sep:", "

let rule_to_string r = "("^(pattern_values_to_string r.guard)^") : "^(r.action.aname)^"("^""^");"
let rules_to_string rs = CL.map rule_to_string rs |> String.concat ~sep:"\n"

let ktype_to_string m = 
  match m with 
    | Ternary -> "ternary"
    | Exact -> "exact"

let key_to_string k = (field_to_string k.kfield)^" : "^(ktype_to_string k.ktype)^";"
let keys_to_string ks = CL.map key_to_string ks |> String.concat ~sep:"\n"


let table_to_string t = 
  let key_string = "key = {\n"^(keys_to_string t.tkeys |> indent_block)^"\n}" in 
  let actions_string = "actions = {\n"^(actions_names_to_string t.tactions |> indent_block)^"\n}" in 
  let entries_string = "const entries = {\n"^(rules_to_string t.trules |> indent_block)^"\n}" in 
  let body_string = (indent_block key_string)^"\n"^(indent_block actions_string)^"\n"^(indent_block entries_string) in 
  sprintf "table %s {\n%s\n}" t.tname body_string
;;

let table_to_call_string t = t.tname^(".apply();")



let test_printers () = 
  let test_action = {
    aname = "test_action";
    aparams = [];
    acmds = ["do_foo()"]
  }
  in 
  let test_guard = 
    [{field = "ip.src"; value = VInt(10)}] 
  in 
  let test_rule = {
    guard = test_guard;
    action = test_action;
    action_args = [];
  } 
  in 

  let test_table = {
    tname = "test_table";
    tkeys = [{kfield = "ip.src"; ktype = Ternary;}];
    tactions = [test_action];
    trules = [test_rule];
  } in   
  print_endline ("test action: ");
  print_endline (action_to_string test_action);
  print_endline ("test_table: ");
  print_endline (table_to_string test_table)
;;



(**** event spec to action / table translators ****)

let argument_to_command ev_name (param, field) = 
  sprintf "%s.%s.%s = %s;" LLConstants.md_instance_prefix ev_name param field
let arguments_to_commands ev_name a_s = CL.map (argument_to_command ev_name) a_s

(* convert the conditions to invoke an action, of the form: 
    x=a && y=(b || c) && z=(d || e || f)
   into guards, where each guard is a disjunction and the list of 
   guards is a conjunction: 
    (x=a && y=b && z=d) || (x=a && y=b && z=e) || ... || (x=a && y=c && z=f)
*)
let conditions_to_guards (conditions:(string * field_val list) list) = 
  (* 
    example: 
      conditions: 
        "foo" : [1; 2]
        "bar" : [3; 4]
  *)
  let pattern_fields = CL.map fst conditions in (* ["foo"; "bar"] *)
  let pattern_values_lists = all_combinations (CL.map snd conditions) in (* [[1; 3]; [1; 4]; [2; 3]; [2; 4]] *)
  let patterns_lists = CL.map 
    (fun pattern_values -> CL.combine pattern_fields pattern_values) 
    pattern_values_lists 
  in (* [[(foo, 1); (bar, 3)]; [(foo, 1); (bar, 4)]; [(foo, 2); (bar, 3)]; [(foo, 2); (bar, 4)]] *)
  let guard_of_tuples si_s = 
    let pattern_of_tuple (s, (i:field_val)) = 
      {field = s; 
        value = match i with 
          | FVInt i -> VInt i
          | FVBool b -> VBool b
        ;
      }
    in 
    CL.map pattern_of_tuple si_s 
  in  
  (* the list of guards. Each guard is for a different rule. *) 
  let guards = CL.map guard_of_tuples patterns_lists in 
  guards 
;;

let event_const_id = LLOp.TofinoStructs.defname_from_evname
;;

let set_event_type_cmd ename = 
  sprintf "%s.%s.%s=%s;" LLConstants.md_instance_prefix LLConstants.dpt_meta_str LLConstants.handle_selector_str (event_const_id ename)
;;

(* accumulate actions and rules for event specs. *)
let event_spec_to_action_rules_accumulator (acns, rules) e = 
  let acn = {
    aname = ("trigger_"^e.name);
    aparams = [];
    acmds = (set_event_type_cmd e.name)::(arguments_to_commands e.name e.arguments);
    } 
  in 
  let guards = conditions_to_guards e.conditions in 
  let new_rules = CL.map (fun guard -> {guard = guard; action = acn; action_args = [];}) guards in 
  (acns@[acn], rules@new_rules)
;;
let event_specs_to_action_rules es = 
  CL.fold_left event_spec_to_action_rules_accumulator ([], []) es
;;


let pattern_to_tup p = (p.field, p.value) ;;
let tup_to_pattern (f, v) = {field = f; value = v;} ;;

let all_fields_of_rules rs = 
  (* get a list of all fields used in all the rules. *)
  let fold_fields fields r = 
    let new_fields = CL.map (fun pattern -> pattern.field) r.guard in 
    fields@new_fields
  in 
  let all_fields = CL.fold_left (fold_fields) [] rs |> unique_list_of in    
  all_fields 
;;

let normalize_rules rs = 
  (* update all rules so that they all test the same fields in the same order. *)  
  let all_fields = all_fields_of_rules rs in 
  let default_guard_tups = CL.map (fun field -> (field, VAny)) all_fields in 
  (* update a rule so that it tests the default_guard, updated with 
     values for any indicated fields. *)
  let normalize_rule r = 
    let guard_tups = CL.map pattern_to_tup r.guard in 
    let replace_in tups (k, v) = replace_or_app (k, v) tups in 
    let normalized_tups = CL.fold_left replace_in default_guard_tups guard_tups in 
    let normalized_guard = CL.map tup_to_pattern normalized_tups in 
    {r with guard = normalized_guard}
  in
  CL.map normalize_rule rs
;;

let generate configfn =
  let _ = configfn in  
  print_endline ("TriggerTable.generate reading config file: "^(configfn));
  let json = In_channel.read_all configfn |> Yojson.Basic.from_string in 
  let json_event_specs = json |> member "triggers" in 
  (* convert json into event spects *)
  let event_specs = convert_each extract_event_spec json_event_specs in 
  (* CL.iter dbg_print_event_spec event_specs; *)

  let actions, rules = event_specs_to_action_rules event_specs in 
  let rules = normalize_rules rules in 
  let keys = all_fields_of_rules rules |> CL.map (fun field -> {kfield=field; ktype=Ternary;}) in 
  let table = {
    tname = "entry_triggers";
    tkeys = keys;
    tactions = actions;
    trules = rules;
    }
  in 
  let actions_string = actions_to_string actions in 
  let table_string = table_to_string table in 
  print_endline ("------- actions -------");
  print_endline (actions_string);
  print_endline ("------- table   -------");
  print_endline (table_string);
  print_endline "\ndone.";
  let obj_string = actions_string^"\n"^table_string in 
  let call_string = table_to_call_string table in 
  [(obj_pragma, obj_string); (call_pragma, call_string)]
;;