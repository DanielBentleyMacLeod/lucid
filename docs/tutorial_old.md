# Tutorial 1: Introduction to Lucid

This tutorial introduces the core features of Lucid and walk through the process of running a program on the Lucid interpreter. 

## Core Lucid abstractions
There are three core abstractions in Lucid: events, handlers, and arrays. To see how we use these primitives, lets look at ``examples/netflow.dpt`` -- a simple flow monitoring application that reports the average packet size of every active flow (defined by source address) to a collection server at regular intervals.

Here's a visual representation of ``netflow.dpt``. 

``examples/copy.dpt`` is a simple program that 


nat


packet-clocked counter

measure 
    average packet size
every n packets, scan all tables and report to controller. 

nat: 
    pkt(src, dst):
        if (key in table):
            pktout(table)


pkt(src, dst):
    read array2[(src, dst)]        
        if empty, control

control(src, dst): 
    read array1[src]:
        if (src is trusted):

    if src is allowed, add dst



is a simple program that demonstrates these primitives. ``copy.dpt`` just creates three copies of each packet. 
copies each packet three tim

Here's an illustration of ``copy.dpt``: 




``examples/control_loop.dpt``, shown below, is a simple program that demonstrates these primitives. 


```
// Events
entry event ip_in (int<<9>> igr_port, int src, int dst, int<<16>> len, int<<8>> tos);
event loop (int<<9>> port);
exit event ip_out (int<<1>> drop, int<<9>> egr_port);

// Arrays and memops
global Array.t<<32>> counters = Array.create(1024);
memop incr(int memval, int incrval) {
    return memval + incrval;
}

// Handlers
handle ip_in (int<<9>> igr_port, int src, int dst, int<<16>> len, int<<8>> tos) {
    generate loop(igr_port);
}

handle loop(int<<9>> port){    
    // increment counter and get new value. 
    int count = Array.update(counters, 0, incr, 1, incr, 1);
    if (count == 9){
        generate ip_out(0, port);                
    } else {
        generate loop(port);        
    }
}
```


### Events
Events abstract *data plane packets* and *control plane messages*. There are three events in the example: ``ip_in``; ``loop``; and ``ip_out``. Each event carries data as event parameters. For example, an ``ip_in`` event carries ``src``, ``dst``, and other parameters. 

**Kinds of events.** There are three kinds of events. 

- *entry* events are generated by the underlying switch for Lucid to handle. ``ip_in`` is an entry event that represents an IP packet that arrives at the switch. 

- *exit* events are generated by the Lucid program for the underlying switch to handle. ``ip_out`` is an exit event that represents an IP packet that Lucid has finished processing and is emitting back to the underlying switch. 

- *control* events are generated by the Lucid program, for another part of the Lucid program to handle.``loop`` is a control event that will cause a counter to be incremented. 


### Handlers
When events occur at a Lucid switch, they get processed by handlers. As we can see in ``control_loop.dpt``, there is exactly one handler for each event.

Handlers can generate other events. For example the ``ip_in`` event always generates a ``loop`` event. When a handler generates a control event, the event is serialized into a packet, recirculated, and processed by the appropriate handler in a subsequent pass through the switch. When a handler generate an exit event, no recirculation is done: the packet simply returns to the underlying switch for forwarding. 

Handlers perform computation over two kinds of state: local state, which persists only for the duration of a single handler's execution, and global state, which persists for the entire program. In ``control_loop.dpt``, we see both kinds of state: ``int count`` is a local variable inside of the ``loop`` handler, and the array ``counters`` is a global variable. 


Inside of a handler, you can't do recursion, iteration, or looping. These abstractions, unfortunately, don't map well to data plane hardware which can only execute a small number of sequential instructions in each pass through a fixed-length pipeline. However, in Lucid, you can write *recursive handlers/events* that use packet recirculation to implement arbitrary recursion / iteration / looping. ``loop`` is an example of a recursive handler. It increments a counter by 1 and checks if the counter has reached 10. If not, it generates another ``loop`` event.
```
handle loop(int<<9>> port){    
    // increment counter and get new value. 
    int count = Array.update(counters, 0, incr, 1, incr, 1);
    if (count == 10){
        generate ip_out(0, port);                
    } else {
        generate loop(port);        
    }
}
```
Recursive events are poweful, but must be used carefully because excessive recirculation reduces the effective data-plane throughput of your switch. 
For example, if every packet generated a ``loop`` event, the switch would wind up having to process 10 packets for every IP packet, reducing its effective throughput to 1/10th. Fortunately, in most cases, recursion is something that you use to implement complicated control operations, which are far less common than data plane packets. 

## Arrays

Lucid's ```Array``` module is its interface to state that persists across handlers. 


