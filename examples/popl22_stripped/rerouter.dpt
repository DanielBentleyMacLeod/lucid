const int TRUE = 1;
const int FALSE = 0;
const int neighbor_ct = 8;
const int INF = 2147483647; const int NO_ROUTE = 255; const int tbl_sz = 1024;
const int t_down = 10000000;
const int t_wait = 10000;

const int SELF = 0;
group NEIGHBORS = {1};

global Array.t<<32>> nexthop_pathlen  = Array.create(tbl_sz);
global Array.t<<32>> nexthop_nid  = Array.create(tbl_sz);

global Array.t<<32>> last_seen = Array.create(neighbor_ct);
global Array.t<<32>> nid_port = Array.create(neighbor_ct);

global Array.t<<32>> noroute_ct = Array.create(tbl_sz);
global Array.t<<32>> linkdown_ct = Array.create(tbl_sz);

entry event packetin(int dst);
exit event packetout(int outport);

event query_nexthop (int q_nid, int dst);

event reply_nexthop (int r_nid, int dst, int len_from_nexthop);

event update_route(int i);

event query_probe (int src_nid);

event reply_probe (int nid);

event check_neighbors();

memop update_pathlen(int cur_pathlen, int len_from_nexthop) {
            if ((len_from_nexthop + 1) < cur_pathlen)  {
        return len_from_nexthop + 1;
    }
    else{
        return cur_pathlen;
    }
}

memop test_path_change(int cur_pathlen, int len_from_nexthop) {
    if ((len_from_nexthop + 1) < cur_pathlen) {
                return TRUE;
    }
    else {
                return FALSE;
    }
}

memop nid_is_down(int last_seen_ts, int cur_ts) {
                        if ((cur_ts - last_seen_ts) > t_down) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

memop incr_ctr(int cur_val, int incr_by) {
    return cur_val + incr_by;
}

handle packetin(int dst) {
    int ts = Sys.time();
        int next_hop = Array.get(nexthop_nid, dst);
    int nexthop_is_down = Array.getm(last_seen, next_hop, nid_is_down, ts);
    if ((next_hop != NO_ROUTE)) {
        if (nexthop_is_down == FALSE) {
            int outport = Array.get(nid_port, next_hop);
            generate packetout(outport);
        }
    }
                    if (next_hop == NO_ROUTE) {
        Array.setm(noroute_ct, dst, incr_ctr, 1);
    }
    else {
        if (nexthop_is_down == TRUE) {
            Array.setm(linkdown_ct, dst, incr_ctr, 1);
        }
    }
}

handle query_nexthop(int q_nid, int dst) {
    int pathlen = Array.get(nexthop_pathlen, dst);
    generate Event.sslocate(reply_nexthop(SELF, dst, pathlen), q_nid);
}

handle reply_nexthop (int r_nid, int dst, int len_from_nexthop) {
                        int found_shorter_path = Array.update(nexthop_pathlen, dst,
        test_path_change, len_from_nexthop,
        update_pathlen, len_from_nexthop);
        if (found_shorter_path == TRUE) {
        Array.set(nexthop_nid, dst, r_nid);
    }
}

handle update_route(int i) {
    int ts = Sys.time();
    int next_i = i + 1;
    int pathlen = Array.get(nexthop_pathlen, i);
            if (pathlen == INF) {
        mgenerate Event.smlocate(query_nexthop(SELF, i), NEIGHBORS);
    }
    else {
                                        if (pathlen != 0) {
            int next_hop = Array.get(nexthop_nid, i);
            int nexthop_is_down = Array.getm(last_seen, next_hop, nid_is_down, ts);
            if (nexthop_is_down == TRUE) {
                mgenerate Event.smlocate(query_nexthop(SELF, i), NEIGHBORS);
            }
        }
    }
        if (next_i == 0) {         generate Event.delay(update_route(next_i), t_wait);
    } else {
        generate update_route(next_i);
    }
}

handle query_probe(int src_nid) {
    generate Event.sslocate(reply_probe(SELF), src_nid);
}
handle reply_probe (int nid) {
    int ts = Sys.time();
    Array.set(last_seen, nid, ts);
}

handle check_neighbors() {
    mgenerate Event.smlocate(query_probe(SELF), NEIGHBORS);
    generate Event.delay(check_neighbors(), t_wait);
}
