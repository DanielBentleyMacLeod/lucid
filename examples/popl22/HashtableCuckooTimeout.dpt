include "Memops.dpt"
include "HashtableTimeout.dpt"

// Multi-stage hash table which attempts to reinsert entries in case of collision.
// Uses events instead of functions because it requires recirculation.
module CuckooTimeout {
  type t<<'k, 'key_sz, 'stages>> = {
    Hashtable.t<<'k, 'key_sz>>['stages] arrs;
  }

  constr t<<'k, 'key_sz, 'stages>> create(int length, int['stages] seeds) = {
    arrs = [Hashtable.create(length, seeds[i]) for i < 'stages];
  };

  fun Hashtable.arg<<'k>> null_arg() {
    return {
            vals = [0 for i < 'k];
            timestamp = 0;
           };
  }

  fun bool all_null(int['k] lst) {
    bool acc = true;
    for (i < 'k) {
      acc = acc && (lst[i] == 0);
    }
    return acc;
  }

  event insert_internal(t<<'k, 'key_sz, 'stages>> tbl, int['k] args, int timestamp, int['k] orig_args, int retry_count) {
    Hashtable.arg<<'k>> victims = {vals = args; timestamp = timestamp};
    Hashtable.arg<<'k>> orig_victims = victims;
    for (i < 'k) {
      if (all_null(victims#vals) == false) {
        // Add to the next stage and evict whatever's there currently
        victims = Hashtable.add_arg(tbl#arrs[i], victims);
      }
    }

    // If something ended up being evicted at the end, try again to insert it
    if (all_null(victims#vals) == false) {
      // if(args == orig_args) {
      //   retry_count = retry_count + 1;
      // }
      bool all_eq = true;
      for (i < 'k) {
        all_eq = all_eq && (args[i] == orig_args[i]);
      }
      if (all_eq) {
        retry_count = retry_count + 1;
      }
      // Retry_count of 'k means the table is full, I think.
      if (retry_count < size_to_int('k)) {
        generate insert_internal(tbl, args, timestamp, orig_args, retry_count);
      }
    }
  }

  event insert(t<<'k, 'key_sz, 'stages>> tbl, int['k] args, int timestamp) {
    generate insert_internal(tbl, args, timestamp, args, 0);
  }

  // Return true if args is in the hash table
  fun bool mem(t<<'k, 'key_sz, 'stages>> tbl, int['k] args) {
    for (i < 'k) {
      if(Hashtable.mem(tbl#arrs[i], args)) { return true; }
    }
    return false;
  }

  // Return true if args is in the hash table, and update its timestamp if it is
  fun bool mem_touch(t<<'k, 'key_sz, 'stages>> tbl, int['k] args, int timestamp) {
    for (i < 'k) {
      if(Hashtable.mem_touch(tbl#arrs[i], args, timestamp)) { return true; }
    }
    return false;
  }

  // Need this to be an event since we only generate it after accessing the timestamp
  /* Simple, but doesn't work until we extend global arg elimination to handle
     vector index arguments.
  event delete(Hashtable.t<<'k, 'key_sz>> hashtbl, int idx) {
    Hashtable.clear_idx(hashtbl, idx);
  }
  */

  event delete(t<<'k, 'key_sz, 'stages>> tbl, int stage, int idx) {
    for (i < 'k) {
      if (stage == size_to_int(i)) {
        Hashtable.clear_idx(tbl#arrs[i], idx);
      }
    }
  }

  // Background event for clearing out old entries in the table
  event scan(t<<'k, 'key_sz, 'stages>> tbl, int idx, int thresh, int period) {
    for(i < 'k) {
      // Sacrificing abstraction for convenience by accessing timestamps directly
      bool timed_out = (Array.getm(tbl#arrs[i]#timestamps, idx, gt, thresh) == 1);
      if (timed_out) {
        // generate delete(tbl#arrs[i], idx); // Use this line after extending global arg elimination
        generate delete(tbl, size_to_int(i), idx); // This will do for now
      }
    }
    idx = idx + 1; // Assume this overflows if necessary
    // event next_scan = scan(tbl, idx, thresh, period);
    generate Event.delay(scan(tbl, idx, thresh, period), period);
  }


}
