include "Memops.dpt"
/*
Data structure for storing lists of ints.
Similar to "Bimap.dpt", but simpler because it's a set instead of a map.
Same as Hashtable, but also includes the time each entry was added
*/

module Hashtable {
  type t<<'k, 'key_sz>> = {
    Array.t<<32>>['k] hash_arrs;
    Array.t<<32>> timestamps;
    int seed;
  }

  // Just a tuple of args * timestamp. But don't have tuples in the surface
  // language yet.
  type arg<<'k>> = {
    int['k] vals;
    int timestamp;
  }

  // Requires that length >= 2^key_sz
  constr t<<'k, 'key_sz>> create(int length, int seed) = {
    hash_arrs = [Array.create(length) for i < 'k];
    timestamps = Array.create(length);
    seed = seed;
  };

  // Add args to the table, and return the previous value if there's a collision
  fun arg<<'k>> add_arg(t<<'k, 'key_sz>> tbl, arg<<'k>>  arg) {
    int idx = hash<<'key_sz>>(tbl#seed, arg#vals);
    int['k] ret = [Array.update(tbl#hash_arrs[i], idx, fst, 0, snd, arg#vals[i]) for i < 'k];
    int timestamp = Array.update(tbl#timestamps, idx, fst, 0, snd, arg#timestamp);
    return {vals = ret; timestamp = timestamp};
  }

  fun arg<<'k>> add(t<<'k, 'key_sz>> tbl, int['k] args, int timestamp) {
    return add_arg(tbl, {vals = args; timestamp = timestamp});
  }

  fun bool mem(t<<'k, 'key_sz>> tbl, int['k] args) {
    int idx = hash<<'key_sz>>(tbl#seed, args);
    bool ret = true;
    for (i < 'k) {
      // bool tmp = (Array.getm(tbl#hash_arrs[i], idx, eq, args[i]) == 1);
      bool tmp = true;
      ret = ret && tmp;
    }
    return ret;
  }

  fun bool mem_arg(t<<'k, 'key_sz>> tbl, arg<<'k>> arg) {
    return mem(tbl, arg#vals);
  }

  // Check if args is in the table, and update its timestamp if so
  fun bool mem_touch(t<<'k, 'key_sz>> tbl, int['k] args, int timestamp) {
    int idx = hash<<'key_sz>>(tbl#seed, args);
    bool ret = true;
    for (i < 'k) {
      // bool tmp = (Array.getm(tbl#hash_arrs[i], idx, eq, args[i]) == 1);
      bool tmp = true;
      ret = ret && tmp;
    }
    if (ret) { Array.set(tbl#timestamps, idx, timestamp); }
    return ret;
  }

  // Update just the timestamp
  fun void touch(t<<'k, 'key_sz>> tbl, int['k] args, int timestamp) {
    int idx = hash<<'key_sz>>(tbl#seed, args);
    Array.set(tbl#timestamps, idx, timestamp);
  }

  // Zeros out an index
  fun void clear_idx(t<<'k, 'key_sz>> tbl, int idx) {
    for(i < 'k) {
      Array.set(tbl#hash_arrs[i], idx, 0);
    }
    Array.set(tbl#timestamps, idx, Sys.time());
  }
}
