include "Memops.dpt"
/*
This module maps vectors of k1 integers to vectors of k2 other integers using a hash
function and a hash table. Specifically, the mapping for k1 -> k2 uses the hash
functions (one for each element of k2), and the mapping for k2 back to k1 uses the
elements of k2 as indices into arrays sorting the original values.

An example of such a map is a NAT, which maps vectors of [source_ip, source_port] to
the singleton vector [output_port], and also translates backwards when receiving
traffic destined to that output port.

I don't see any good way to handle collisions if 'k2 > 1 though.
*/

// Version which assumes 'k2 = 1. Probably more useful in practice.
// No less efficient than the general version, since vectors and loops get inlined
// away.
module Bimap {
  type t<<'k1, 'key_sz>> = GeneralBimap.t<<'k1, 1, 'key_sz>>

  constr t<<'k1, 'key_sz>> create(int len, int seed) = GeneralBimap.create(len, [seed]);

  fun int map_forward(t<<'k1, 'sz>> map, int['k1] args) {
    return GeneralBimap.map_forward(map, args)[0];
  }

  // Add the arguments to the table, and return the previous values
  fun int['k1] add(t<<'k1, 'sz>> map, int['k1] args) {
    return GeneralBimap.add(map, args)[0];
  }

  fun int['k1] lookup_forward(t<<'k1, 'sz>> map, int['k1] args) {
    return GeneralBimap.lookup_forward(map, args)[0];
  }

  fun int['k1] lookup_backward(t<<'k1, 'sz>> map, int key) {
    return GeneralBimap.lookup_backward(map, [key])[0];
  }

  fun bool in_map_forward(t<<'k1, 'sz>> map, int['k1] args) {
    return GeneralBimap.in_map_forward(map, args);
  }

  fun bool in_map_backward(t<<'k1, 'sz>> map, int key) {
    return GeneralBimap.in_map_backward(map, [key]);
  }
}
